<div class="row">
  <div class="col-lg-8">
    <div class="card shadow-sm">
      <div class="card-header bg-primary text-white">
        <h3 class="card-title mb-0">üéæ Predicci√≥n de Partido de Tenis</h3>
      </div>
      <div class="card-body">
        <p class="lead">Selecciona dos jugadores para predecir el ganador usando nuestro algoritmo de IA.</p>
        
        <%= form_with url: predict_predictions_path, method: :post, local: true, class: "needs-validation", novalidate: true do |form| %>
          <div class="row g-3">
            <div class="col-md-6">
              <label for="player1_id" class="form-label">Jugador 1</label>
      <%= form.select :player1_id, 
        options_from_collection_for_select(@players, :id, :name), 
        { prompt: "Selecciona el primer jugador..." }, 
        { class: "form-select", required: true, name: 'player1_id' } %>
              <div class="invalid-feedback">
                Por favor selecciona el primer jugador.
              </div>
            </div>
            
            <div class="col-md-6">
              <label for="player2_id" class="form-label">Jugador 2</label>
      <%= form.select :player2_id, 
        options_from_collection_for_select(@players, :id, :name), 
        { prompt: "Selecciona el segundo jugador..." }, 
        { class: "form-select", required: true, name: 'player2_id' } %>
              <div class="invalid-feedback">
                Por favor selecciona el segundo jugador.
              </div>
            </div>
          </div>
          
          <div class="row mt-4">
            <div class="col-12">
              <div class="d-grid gap-2">
                <!-- First the button to load recent matches inline (hidden until both players selected) -->
                <button id="checkRecentMatchesBtn" type="button" class="btn btn-outline-primary btn-lg d-none">Ver partidos recientes entre estos jugadores</button>
                <!-- Generate prediction button: hidden until recent matches are loaded -->
                <button id="generatePredictionBtn" type="button" class="btn btn-success btn-lg w-100 d-none">Generar predicci√≥n para pr√≥ximo partido</button>
              </div>
            </div>
          </div>
          <!-- Inline container where recent matches will be injected -->
          <div id="recent-matches-container" class="mt-4"></div>
        <% end %>
      </div>
    </div>
    
    <% if @players.empty? %>
      <div class="alert alert-info mt-4" role="alert">
        <h5>No hay jugadores disponibles</h5>
        <p>Parece que no tenemos datos de jugadores a√∫n. Haz clic abajo para cargar el ranking ATP.</p>
        <%= link_to "Cargar datos de jugadores", scrape_data_predictions_path, method: :post, class: "btn btn-primary" %>
      </div>
    <% end %>
  </div>
  
  <div class="col-lg-4">
    <div class="card shadow-sm">
      <div class="card-header">
        <div class="d-flex justify-content-between align-items-center">
          <h5 class="card-title mb-0">Predicciones recientes</h5>
          <%= button_to 'Borrar historial', clear_history_predictions_path, method: :post, form: { data: { turbo: false } }, params: {}, class: 'btn btn-sm btn-danger', data: { confirm: '¬øSeguro que quer√©s borrar todo el historial de predicciones? Esta acci√≥n no se puede deshacer.' } %>
        </div>
      </div>
      <div class="card-body" id="recent-predictions-container">
        <%= render partial: 'predictions/recent_predictions', locals: { recent: @recent_predictions } %>
      </div>
    </div>
    
    <% if @favorites.present? %>
      <div class="card shadow-sm mt-4">
        <div class="card-header">
          <h5 class="card-title mb-0">Tus favoritos</h5>
        </div>
        <div class="card-body">
          <p class="text-muted small">Haz click en un jugador para seleccionarlo como Jugador 1 en el formulario.</p>
          <div class="list-group">
            <% @favorites.each do |fav| %>
              <button type="button" class="list-group-item list-group-item-action favorite-player" data-player-id="<%= fav.id %>" data-player-name="<%= fav.name %>"><%= fav.name %> <small class="text-muted">#<%= fav.rank %></small></button>
            <% end %>
          </div>
        </div>
      </div>
    <% end %>
    
    <div class="card shadow-sm mt-4">
      <div class="card-header">
        <h5 class="card-title mb-0">¬øC√≥mo funciona?</h5>
      </div>
      <div class="card-body">
        <ul class="list-unstyled">
          <li class="mb-2">üèÜ <strong>Ranking:</strong> Posici√≥n y puntos ATP actuales</li>
          <li class="mb-2">üìä <strong>Historial:</strong> Resultados de enfrentamientos previos</li>
          <li class="mb-2">üìà <strong>Forma reciente:</strong> Rendimiento en los √∫ltimos 10 partidos</li>
          <li class="mb-2">ü§ñ <strong>Algoritmo IA:</strong> Modelo de predicci√≥n con machine learning</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<!-- Modal for prediction result -->
<div class="modal fade" id="predictionModal" tabindex="-1" aria-labelledby="predictionModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header bg-success text-white">
        <h5 class="modal-title" id="predictionModalLabel">Resultado de la Predicci√≥n</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Cerrar"></button>
      </div>
      <div class="modal-body text-center" id="predictionModalBody">
        <!-- El resultado aparecer√° aqu√≠ -->
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
      </div>
    </div>
  </div>
</div>

<script>
// Bootstrap form validation
(function() {
  'use strict';
  window.addEventListener('load', function() {
    var forms = document.getElementsByClassName('needs-validation');
    var validation = Array.prototype.filter.call(forms, function(form) {
      form.addEventListener('submit', function(event) {
        if (form.checkValidity() === false) {
          event.preventDefault();
          event.stopPropagation();
        }
        form.classList.add('was-validated');
      }, false);
    });
  }, false);
})();

// Show modal with prediction result after form submit
function showPredictionModal(resultHtml) {
  document.getElementById('predictionModalBody').innerHTML = resultHtml;
  var modal = new bootstrap.Modal(document.getElementById('predictionModal'));
  modal.show();
}

// Attach generate prediction button logic (posts the form and shows the modal)
const form = document.querySelector('form');
const generateBtn = document.getElementById('generatePredictionBtn');
if (generateBtn && form) {
  generateBtn.addEventListener('click', function(e) {
    try {
      const p1 = document.querySelector('select[name="player1_id"]')?.value;
      const p2 = document.querySelector('select[name="player2_id"]')?.value;
      if (!p1 || !p2) {
        alert('Por favor selecciona ambos jugadores antes de generar la predicci√≥n.');
        return;
      }

      // Build JSON payload and include CSRF token in header
      const payload = { player1_id: p1, player2_id: p2 };
      const csrf = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
  // Use preview endpoint (non-persisted) for in-page generation to avoid
  // redirects or unexpected server-side behavior. This returns JSON with
  // predicted_winner and confidence so it's ideal for UI previews.
  const url = '<%= preview_predictions_path %>';

      console.log('Generating prediction', payload, 'POST', url);

      fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-CSRF-Token': csrf || ''
        },
        body: JSON.stringify(payload)
      })
      .then(response => {
        if (!response.ok) throw new Error('HTTP ' + response.status);
        return response.json();
      })
      .then(data => {
        if (data.error) {
          showPredictionModal(`<div class="alert alert-danger">${data.error}</div>`);
          return;
        }

        // preview returns predicted_winner (name) and confidence in percent
        let winner = data.predicted_winner || data.predicted_winner_name || data.player1 || '';
        let confidence = data.confidence || data.confidence_percent || (data.confidence ? (data.confidence * 100).toFixed(1) : 'N/A');
        let html = `<h2>El jugador con m√°s probabilidad de ganar es:</h2><h1 class='text-success'>${winner}</h1><h4>Confianza: <span class='badge bg-success'>${confidence}%</span></h4><div id="prediction-save-status" class="mt-3"></div>`;
        showPredictionModal(html);

        // Also persist the prediction to history by calling the server-side `predict` endpoint.
        // We call this after preview so the UI remains responsive and the user sees the result quickly.
        const predictUrl = '<%= predict_predictions_path %>';
        fetch(predictUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-CSRF-Token': csrf || ''
          },
          body: JSON.stringify(payload)
        })
        .then(r => r.json().then(body => ({ ok: r.ok, status: r.status, body })))
        .then(({ ok, status, body }) => {
          const statusEl = document.getElementById('prediction-save-status');
          if (!statusEl) return;
          if (ok) {
            statusEl.innerHTML = `<div class="text-success">‚úÖ Guardada en historial</div>`;
            // Refresh recent predictions panel to show the newly saved prediction
            try { fetchRecentPredictions(); } catch (e) { console.debug('Could not refresh recent predictions', e); }
          } else {
            // Server returned an error payload; show message
            const msg = (body && body.error) ? body.error : `Error al guardar (status ${status})`;
            statusEl.innerHTML = `<div class="text-danger">‚ö†Ô∏è ${msg}</div>`;
          }
        })
        .catch(err => {
          const statusEl = document.getElementById('prediction-save-status');
          if (statusEl) statusEl.innerHTML = `<div class="text-danger">‚ö†Ô∏è Error guardando predicci√≥n</div>`;
          console.error('Error persisting prediction', err);
        });
      })
      .catch(err => {
        console.error('Prediction error', err);
        showPredictionModal(`<div class="alert alert-danger">Hubo un error al generar la predicci√≥n. Reintentar.</div>`);
      });
    } catch (err) {
      console.error('Generate prediction handler failed', err);
      alert('Error interno. Reintentar.');
    }
  });
}
</script>

<script>
// Fetch recent matches between selected players
// Fetch recent matches and render inline (not modal). Reveal generate button after load.
// Show the 'Ver partidos recientes' button only after both selectors have values
function toggleCheckButtonVisibility() {
  const p1 = document.querySelector('select[name="player1_id"]')?.value;
  const p2 = document.querySelector('select[name="player2_id"]')?.value;
  const btn = document.getElementById('checkRecentMatchesBtn');
  if (!btn) return;
  if (p1 && p2 && p1 !== p2) {
    btn.classList.remove('d-none');
  } else {
    btn.classList.add('d-none');
  }
}

document.querySelectorAll('select[name="player1_id"], select[name="player2_id"]').forEach(s => s.addEventListener('change', toggleCheckButtonVisibility));

// Trigger once on load in case selects are prefilled
toggleCheckButtonVisibility();

document.getElementById('checkRecentMatchesBtn')?.addEventListener('click', function() {
  const p1 = document.querySelector('select[name="player1_id"]')?.value;
  const p2 = document.querySelector('select[name="player2_id"]')?.value;
  if (!p1 || !p2) {
    alert('Por favor selecciona ambos jugadores antes de buscar partidos recientes.');
    return;
  }

  const container = document.getElementById('recent-matches-container');
  container.innerHTML = `<div class="text-muted">Cargando partidos recientes‚Ä¶</div>`;

  fetch(`<%= recent_matches_predictions_path %>?player1_id=${p1}&player2_id=${p2}`, { headers: { 'Accept': 'application/json' } })
    .then(r => r.json())
    .then(data => {
      let html = '';
      if (data.matches && data.matches.length > 0) {
        html += `<h5 class="mb-3">Fuente: ${data.source}</h5>`;
        data.matches.forEach(m => {
          html += `<div class="mb-2 p-2 border rounded">`;
          html += `<div class="d-flex justify-content-between"><div><strong>${m.player1}</strong> vs <strong>${m.player2}</strong> <small class="text-muted">(${m.date})</small></div><div><small class="text-muted">${m.surface || ''}</small></div></div>`;
          html += `<div class="mt-1"><small>${m.tournament || ''} ${m.score ? ' ‚Ä¢ Score: ' + m.score : ''}</small></div>`;
          html += `</div>`;
        });
      } else {
        html = '<div class="alert alert-info">No se encontraron partidos recientes entre estos jugadores.</div>';
      }

      container.innerHTML = html;

      // Reveal generate button (show and enable)
      const gen = document.getElementById('generatePredictionBtn');
      if (gen) {
        gen.classList.remove('d-none');
        gen.disabled = false;
        gen.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    })
    .catch(err => {
      console.error('Error fetching recent matches', err);
      container.innerHTML = '<div class="alert alert-danger">Hubo un error al obtener los partidos recientes. Reintentar.</div>';
    });
});
</script>

<script>
// Poll recent predictions every 6 seconds and update the container
function fetchRecentPredictions() {
  fetch('<%= recent_predictions_path %>', { headers: { 'Accept': 'application/json' } })
    .then(resp => resp.json())
    .then(data => {
      const container = document.getElementById('recent-predictions-container');
      if (!container) return;
      // Build HTML
      if (Array.isArray(data) && data.length > 0) {
        let html = '';
        data.forEach(pred => {
          html += `<div class="d-flex justify-content-between align-items-center py-2 border-bottom">`;
          html += `<div><small class="text-muted d-block">${pred.player1} vs ${pred.player2}</small><strong>${pred.predicted_winner}</strong> <span class="badge bg-secondary ms-1">${pred.confidence}%</span></div>`;
          html += `<small class="text-muted">${pred.time_ago}</small>`;
          html += `</div>`;
        });
        container.innerHTML = html;
      } else {
        container.innerHTML = '<p class="text-muted">A√∫n no hay predicciones. ¬°Haz tu primera predicci√≥n!</p>';
      }
    })
    .catch(err => console.error('Failed to fetch recent predictions', err));
}

// Start polling
setInterval(fetchRecentPredictions, 6000);
</script>

<script>
// Use event delegation so the handler works with Turbo navigation and doesn't need re-attaching
document.addEventListener('click', function(e) {
  const btn = e.target.closest('.favorite-player');
  if (!btn) return;

  const playerId = btn.dataset.playerId;
  const playerName = btn.dataset.playerName;
  const select1 = document.querySelector('select[name="player1_id"]');
  const select2 = document.querySelector('select[name="player2_id"]');
  if (!select1 || !select2) return;

  function ensureOption(select, id, name) {
    let opt = select.querySelector(`option[value="${id}"]`);
    if (!opt) {
      opt = document.createElement('option');
      opt.value = id;
      opt.text = name;
      select.appendChild(opt);
    }
    return opt;
  }

  const val1 = select1.value;
  const val2 = select2.value;

  // Selection rules:
  // - If player1 is empty -> set player1
  // - Else if player1 is this id -> toggle it off (and if player2 present, shift player2->player1)
  // - Else if player2 is empty and id != player1 -> set player2
  // - Else if player2 is this id -> toggle it off
  // - Else (both filled and id different) -> start a new pair: set player1 = id and clear player2

  if (!val1) {
    ensureOption(select1, playerId, playerName);
    select1.value = playerId;
  } else if (val1 === playerId) {
    // toggle off player1
    if (val2) {
      // shift player2 into player1
      select1.value = val2;
      select2.value = '';
    } else {
      select1.value = '';
    }
  } else if (!val2 && val1 !== playerId) {
    ensureOption(select2, playerId, playerName);
    select2.value = playerId;
  } else if (val2 === playerId) {
    // toggle off player2
    select2.value = '';
  } else {
    // both filled and clicked a third different favorite: restart selection
    ensureOption(select1, playerId, playerName);
    select1.value = playerId;
    select2.value = '';
  }

  // Update active classes on favorite buttons to reflect current selections
  document.querySelectorAll('.favorite-player').forEach(b => {
    b.classList.remove('active');
    const id = b.dataset.playerId;
    if (id === select1.value || id === select2.value) b.classList.add('active');
  });

  // Trigger change handlers so UI updates (e.g., checkRecentMatchesBtn visibility)
  select1.dispatchEvent(new Event('change', { bubbles: true }));
  select2.dispatchEvent(new Event('change', { bubbles: true }));

  // Scroll to the form to show the selection
  select1.scrollIntoView({ behavior: 'smooth', block: 'center' });
});
</script>
